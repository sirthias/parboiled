<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_24) on Wed Apr 06 17:46:14 CEST 2011 -->
<TITLE>
BaseParser (parboiled-java 0.11.1 API)
</TITLE>

<META NAME="date" CONTENT="2011-04-06">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="BaseParser (parboiled-java 0.11.1 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/parboiled/BaseActions.html" title="class in org.parboiled"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/parboiled/Parboiled.html" title="class in org.parboiled"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?org/parboiled/BaseParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BaseParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.parboiled</FONT>
<BR>
Class BaseParser&lt;V&gt;</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../org/parboiled/BaseActions.html" title="class in org.parboiled">org.parboiled.BaseActions</A>&lt;V&gt;
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>org.parboiled.BaseParser&lt;V&gt;</B>
</PRE>
<DL>
<DT><DT><B>Type Parameters:</B><DD><CODE>V</CODE> - the type of the parser values</DL>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>org.parboiled.ContextAware&lt;V&gt;</DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>BaseParser&lt;V&gt;</B><DT>extends <A HREF="../../org/parboiled/BaseActions.html" title="class in org.parboiled">BaseActions</A>&lt;V&gt;</DL>
</PRE>

<P>
Base class of all parboiled parsers. Defines the basic rule creation methods.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#ANY">ANY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches any character except <CODE>Chars.EOI</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#DEDENT">DEDENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches the special <CODE>Chars.DEDENT</CODE> character produces by the org.parboiled.buffers.IndentDedentInputBuffer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#EMPTY">EMPTY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches nothing and always succeeds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#EOI">EOI</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches the <CODE>Chars.EOI</CODE> (end of input) character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#INDENT">INDENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches the special <CODE>Chars.INDENT</CODE> character produces by the org.parboiled.buffers.IndentDedentInputBuffer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#NOTHING">NOTHING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matches nothing and always fails.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#BaseParser()">BaseParser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.parboiled.Action</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#ACTION(boolean)">ACTION</A></B>(boolean&nbsp;expression)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly marks the wrapped expression as an action expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#AnyOf(char[])">AnyOf</A></B>(char[]&nbsp;characters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that matches any of the characters in the given char array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#AnyOf(org.parboiled.support.Characters)">AnyOf</A></B>(org.parboiled.support.Characters&nbsp;characters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that matches any of the given characters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#AnyOf(java.lang.String)">AnyOf</A></B>(java.lang.String&nbsp;characters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that matches any of the characters in the given string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Ch(char)">Ch</A></B>(char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly creates a rule matching the given character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#CharRange(char, char)">CharRange</A></B>(char&nbsp;cLow,
          char&nbsp;cHigh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a rule matching a range of characters from cLow to cHigh (both inclusively).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#FirstOf(java.lang.Object[])">FirstOf</A></B>(java.lang.Object[]&nbsp;rules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that successively tries all of the given subrules and succeeds when the first one of
 its subrules matches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#FirstOf(java.lang.Object, java.lang.Object, java.lang.Object...)">FirstOf</A></B>(java.lang.Object&nbsp;rule,
        java.lang.Object&nbsp;rule2,
        java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that successively tries all of the given subrules and succeeds when the first one of
 its subrules matches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#fromCharArray(char[])">fromCharArray</A></B>(char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used internally to convert the given char array to a parser rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#fromCharLiteral(char)">fromCharLiteral</A></B>(char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used internally to convert the given character literal to a parser rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#fromStringLiteral(java.lang.String)">fromStringLiteral</A></B>(java.lang.String&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used internally to convert the given string literal to a parser rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#IgnoreCase(char...)">IgnoreCase</A></B>(char...&nbsp;characters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly creates a rule matching the given string in a case-independent fashion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#IgnoreCase(char)">IgnoreCase</A></B>(char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly creates a rule matching the given character case-independently.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#IgnoreCase(java.lang.String)">IgnoreCase</A></B>(java.lang.String&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly creates a rule matching the given string in a case-independent fashion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;P extends <A HREF="../../org/parboiled/BaseParser.html" title="class in org.parboiled">BaseParser</A>&lt;<A HREF="../../org/parboiled/BaseParser.html" title="type parameter in BaseParser">V</A>&gt;&gt; 
<BR>
P</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#newInstance()">newInstance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new instance of this parsers class using the no-arg constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#OneOrMore(java.lang.Object)">OneOrMore</A></B>(java.lang.Object&nbsp;rule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#OneOrMore(java.lang.Object, java.lang.Object, java.lang.Object...)">OneOrMore</A></B>(java.lang.Object&nbsp;rule,
          java.lang.Object&nbsp;rule2,
          java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that tries repeated matches of a sequence of the given subrules and succeeds if the sequence
 matches at least once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Optional(java.lang.Object)">Optional</A></B>(java.lang.Object&nbsp;rule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching
 success of its sub rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Optional(java.lang.Object, java.lang.Object, java.lang.Object...)">Optional</A></B>(java.lang.Object&nbsp;rule,
         java.lang.Object&nbsp;rule2,
         java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that tries a match on the sequence of the given subrules and always succeeds, independently
 of the matching success of its sub sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Sequence(java.lang.Object[])">Sequence</A></B>(java.lang.Object[]&nbsp;rules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that only succeeds if all of its subrule succeed, one after the other.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Sequence(java.lang.Object, java.lang.Object, java.lang.Object...)">Sequence</A></B>(java.lang.Object&nbsp;rule,
         java.lang.Object&nbsp;rule2,
         java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that only succeeds if all of its subrule succeed, one after the other.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#String(char...)">String</A></B>(char...&nbsp;characters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly creates a rule matching the given string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#String(java.lang.String)">String</A></B>(java.lang.String&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicitly creates a rule matching the given string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Test(java.lang.Object)">Test</A></B>(java.lang.Object&nbsp;rule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that acts as a syntactic predicate, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#Test(java.lang.Object, java.lang.Object, java.lang.Object...)">Test</A></B>(java.lang.Object&nbsp;rule,
     java.lang.Object&nbsp;rule2,
     java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that acts as a syntactic predicate, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#TestNot(java.lang.Object)">TestNot</A></B>(java.lang.Object&nbsp;rule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that acts as an inverse syntactic predicate, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#TestNot(java.lang.Object, java.lang.Object, java.lang.Object...)">TestNot</A></B>(java.lang.Object&nbsp;rule,
        java.lang.Object&nbsp;rule2,
        java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that acts as an inverse syntactic predicate, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#toRule(java.lang.Object)">toRule</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the given object to a rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#toRules(java.lang.Object...)">toRules</A></B>(java.lang.Object...&nbsp;objects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the given object array to an array of rules.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#ZeroOrMore(java.lang.Object)">ZeroOrMore</A></B>(java.lang.Object&nbsp;rule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that tries repeated matches of its subrule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.parboiled.Rule</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/parboiled/BaseParser.html#ZeroOrMore(java.lang.Object, java.lang.Object, java.lang.Object...)">ZeroOrMore</A></B>(java.lang.Object&nbsp;rule,
           java.lang.Object&nbsp;rule2,
           java.lang.Object...&nbsp;moreRules)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new rule that tries repeated matches of the sequence of the given sub rules.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.parboiled.BaseActions"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.parboiled.<A HREF="../../org/parboiled/BaseActions.html" title="class in org.parboiled">BaseActions</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../org/parboiled/BaseActions.html#currentChar()">currentChar</A>, <A HREF="../../org/parboiled/BaseActions.html#drop()">drop</A>, <A HREF="../../org/parboiled/BaseActions.html#drop(int)">drop</A>, <A HREF="../../org/parboiled/BaseActions.html#dup()">dup</A>, <A HREF="../../org/parboiled/BaseActions.html#getContext()">getContext</A>, <A HREF="../../org/parboiled/BaseActions.html#hasError()">hasError</A>, <A HREF="../../org/parboiled/BaseActions.html#inPredicate()">inPredicate</A>, <A HREF="../../org/parboiled/BaseActions.html#match()">match</A>, <A HREF="../../org/parboiled/BaseActions.html#matchedChar()">matchedChar</A>, <A HREF="../../org/parboiled/BaseActions.html#matchEnd()">matchEnd</A>, <A HREF="../../org/parboiled/BaseActions.html#matchLength()">matchLength</A>, <A HREF="../../org/parboiled/BaseActions.html#matchOrDefault(java.lang.String)">matchOrDefault</A>, <A HREF="../../org/parboiled/BaseActions.html#matchRange()">matchRange</A>, <A HREF="../../org/parboiled/BaseActions.html#matchStart()">matchStart</A>, <A HREF="../../org/parboiled/BaseActions.html#nodeSuppressed()">nodeSuppressed</A>, <A HREF="../../org/parboiled/BaseActions.html#peek()">peek</A>, <A HREF="../../org/parboiled/BaseActions.html#peek(int)">peek</A>, <A HREF="../../org/parboiled/BaseActions.html#poke(int, V)">poke</A>, <A HREF="../../org/parboiled/BaseActions.html#poke(V)">poke</A>, <A HREF="../../org/parboiled/BaseActions.html#pop()">pop</A>, <A HREF="../../org/parboiled/BaseActions.html#pop(int)">pop</A>, <A HREF="../../org/parboiled/BaseActions.html#push(int, V)">push</A>, <A HREF="../../org/parboiled/BaseActions.html#push(V)">push</A>, <A HREF="../../org/parboiled/BaseActions.html#pushAll(V, V...)">pushAll</A>, <A HREF="../../org/parboiled/BaseActions.html#setContext(org.parboiled.Context)">setContext</A>, <A HREF="../../org/parboiled/BaseActions.html#swap()">swap</A>, <A HREF="../../org/parboiled/BaseActions.html#swap3()">swap3</A>, <A HREF="../../org/parboiled/BaseActions.html#swap4()">swap4</A>, <A HREF="../../org/parboiled/BaseActions.html#swap5()">swap5</A>, <A HREF="../../org/parboiled/BaseActions.html#swap6()">swap6</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="EOI"><!-- --></A><H3>
EOI</H3>
<PRE>
public static final org.parboiled.Rule <B>EOI</B></PRE>
<DL>
<DD>Matches the <CODE>Chars.EOI</CODE> (end of input) character.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="INDENT"><!-- --></A><H3>
INDENT</H3>
<PRE>
public static final org.parboiled.Rule <B>INDENT</B></PRE>
<DL>
<DD>Matches the special <CODE>Chars.INDENT</CODE> character produces by the org.parboiled.buffers.IndentDedentInputBuffer
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEDENT"><!-- --></A><H3>
DEDENT</H3>
<PRE>
public static final org.parboiled.Rule <B>DEDENT</B></PRE>
<DL>
<DD>Matches the special <CODE>Chars.DEDENT</CODE> character produces by the org.parboiled.buffers.IndentDedentInputBuffer
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="ANY"><!-- --></A><H3>
ANY</H3>
<PRE>
public static final org.parboiled.Rule <B>ANY</B></PRE>
<DL>
<DD>Matches any character except <CODE>Chars.EOI</CODE>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="EMPTY"><!-- --></A><H3>
EMPTY</H3>
<PRE>
public static final org.parboiled.Rule <B>EMPTY</B></PRE>
<DL>
<DD>Matches nothing and always succeeds.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="NOTHING"><!-- --></A><H3>
NOTHING</H3>
<PRE>
public static final org.parboiled.Rule <B>NOTHING</B></PRE>
<DL>
<DD>Matches nothing and always fails.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BaseParser()"><!-- --></A><H3>
BaseParser</H3>
<PRE>
public <B>BaseParser</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="newInstance()"><!-- --></A><H3>
newInstance</H3>
<PRE>
public &lt;P extends <A HREF="../../org/parboiled/BaseParser.html" title="class in org.parboiled">BaseParser</A>&lt;<A HREF="../../org/parboiled/BaseParser.html" title="type parameter in BaseParser">V</A>&gt;&gt; P <B>newInstance</B>()</PRE>
<DL>
<DD>Creates a new instance of this parsers class using the no-arg constructor. If no no-arg constructor
 exists this method will fail with a java.lang.NoSuchMethodError.
 Using this method is faster than using <A HREF="../../org/parboiled/Parboiled.html#createParser(java.lang.Class, java.lang.Object...)"><CODE>Parboiled.createParser(Class, Object...)</CODE></A> for creating
 new parser instances since this method does not use reflection.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>P</CODE> - the parser class
<DT><B>Returns:</B><DD>a new parser instance</DL>
</DD>
</DL>
<HR>

<A NAME="Ch(char)"><!-- --></A><H3>
Ch</H3>
<PRE>
public org.parboiled.Rule <B>Ch</B>(char&nbsp;c)</PRE>
<DL>
<DD>Explicitly creates a rule matching the given character. Normally you can just specify the character literal
 directly in you rule description. However, if you don't want to go through <A HREF="../../org/parboiled/BaseParser.html#fromCharLiteral(char)"><CODE>fromCharLiteral(char)</CODE></A>,
 e.g. because you redefined it, you can also use this wrapper.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the char to match
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="IgnoreCase(char)"><!-- --></A><H3>
IgnoreCase</H3>
<PRE>
public org.parboiled.Rule <B>IgnoreCase</B>(char&nbsp;c)</PRE>
<DL>
<DD>Explicitly creates a rule matching the given character case-independently.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the char to match independently of its case
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="CharRange(char, char)"><!-- --></A><H3>
CharRange</H3>
<PRE>
public org.parboiled.Rule <B>CharRange</B>(char&nbsp;cLow,
                                    char&nbsp;cHigh)</PRE>
<DL>
<DD>Creates a rule matching a range of characters from cLow to cHigh (both inclusively).
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cLow</CODE> - the start char of the range (inclusively)<DD><CODE>cHigh</CODE> - the end char of the range (inclusively)
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="AnyOf(java.lang.String)"><!-- --></A><H3>
AnyOf</H3>
<PRE>
public org.parboiled.Rule <B>AnyOf</B>(java.lang.String&nbsp;characters)</PRE>
<DL>
<DD>Creates a new rule that matches any of the characters in the given string.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>characters</CODE> - the characters
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="AnyOf(char[])"><!-- --></A><H3>
AnyOf</H3>
<PRE>
public org.parboiled.Rule <B>AnyOf</B>(char[]&nbsp;characters)</PRE>
<DL>
<DD>Creates a new rule that matches any of the characters in the given char array.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>characters</CODE> - the characters
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="AnyOf(org.parboiled.support.Characters)"><!-- --></A><H3>
AnyOf</H3>
<PRE>
public org.parboiled.Rule <B>AnyOf</B>(org.parboiled.support.Characters&nbsp;characters)</PRE>
<DL>
<DD>Creates a new rule that matches any of the given characters.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>characters</CODE> - the characters
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="String(java.lang.String)"><!-- --></A><H3>
String</H3>
<PRE>
public org.parboiled.Rule <B>String</B>(java.lang.String&nbsp;string)</PRE>
<DL>
<DD>Explicitly creates a rule matching the given string. Normally you can just specify the string literal
 directly in you rule description. However, if you want to not go through <A HREF="../../org/parboiled/BaseParser.html#fromStringLiteral(java.lang.String)"><CODE>fromStringLiteral(String)</CODE></A>,
 e.g. because you redefined it, you can also use this wrapper.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>string</CODE> - the String to match
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="String(char...)"><!-- --></A><H3>
String</H3>
<PRE>
public org.parboiled.Rule <B>String</B>(char...&nbsp;characters)</PRE>
<DL>
<DD>Explicitly creates a rule matching the given string. Normally you can just specify the string literal
 directly in you rule description. However, if you want to not go through <A HREF="../../org/parboiled/BaseParser.html#fromStringLiteral(java.lang.String)"><CODE>fromStringLiteral(String)</CODE></A>,
 e.g. because you redefined it, you can also use this wrapper.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>characters</CODE> - the characters of the string to match
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="IgnoreCase(java.lang.String)"><!-- --></A><H3>
IgnoreCase</H3>
<PRE>
public org.parboiled.Rule <B>IgnoreCase</B>(java.lang.String&nbsp;string)</PRE>
<DL>
<DD>Explicitly creates a rule matching the given string in a case-independent fashion.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>string</CODE> - the string to match
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="IgnoreCase(char...)"><!-- --></A><H3>
IgnoreCase</H3>
<PRE>
public org.parboiled.Rule <B>IgnoreCase</B>(char...&nbsp;characters)</PRE>
<DL>
<DD>Explicitly creates a rule matching the given string in a case-independent fashion.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>characters</CODE> - the characters of the string to match
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="FirstOf(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
FirstOf</H3>
<PRE>
public org.parboiled.Rule <B>FirstOf</B>(java.lang.Object&nbsp;rule,
                                  java.lang.Object&nbsp;rule2,
                                  java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD>Creates a new rule that successively tries all of the given subrules and succeeds when the first one of
 its subrules matches. If all subrules fail this rule fails as well.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="FirstOf(java.lang.Object[])"><!-- --></A><H3>
FirstOf</H3>
<PRE>
public org.parboiled.Rule <B>FirstOf</B>(java.lang.Object[]&nbsp;rules)</PRE>
<DL>
<DD>Creates a new rule that successively tries all of the given subrules and succeeds when the first one of
 its subrules matches. If all subrules fail this rule fails as well.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rules</CODE> - the subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="OneOrMore(java.lang.Object)"><!-- --></A><H3>
OneOrMore</H3>
<PRE>
public org.parboiled.Rule <B>OneOrMore</B>(java.lang.Object&nbsp;rule)</PRE>
<DL>
<DD>Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.
 If the subrule does not match at least once this rule fails.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the subrule
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="OneOrMore(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
OneOrMore</H3>
<PRE>
public org.parboiled.Rule <B>OneOrMore</B>(java.lang.Object&nbsp;rule,
                                    java.lang.Object&nbsp;rule2,
                                    java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD>Creates a new rule that tries repeated matches of a sequence of the given subrules and succeeds if the sequence
 matches at least once. If the sequence does not match at least once this rule fails.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="Optional(java.lang.Object)"><!-- --></A><H3>
Optional</H3>
<PRE>
public org.parboiled.Rule <B>Optional</B>(java.lang.Object&nbsp;rule)</PRE>
<DL>
<DD>Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching
 success of its sub rule.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the subrule
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="Optional(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
Optional</H3>
<PRE>
public org.parboiled.Rule <B>Optional</B>(java.lang.Object&nbsp;rule,
                                   java.lang.Object&nbsp;rule2,
                                   java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD>Creates a new rule that tries a match on the sequence of the given subrules and always succeeds, independently
 of the matching success of its sub sequence.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="Sequence(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
Sequence</H3>
<PRE>
public org.parboiled.Rule <B>Sequence</B>(java.lang.Object&nbsp;rule,
                                   java.lang.Object&nbsp;rule2,
                                   java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD>Creates a new rule that only succeeds if all of its subrule succeed, one after the other.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="Sequence(java.lang.Object[])"><!-- --></A><H3>
Sequence</H3>
<PRE>
public org.parboiled.Rule <B>Sequence</B>(java.lang.Object[]&nbsp;rules)</PRE>
<DL>
<DD>Creates a new rule that only succeeds if all of its subrule succeed, one after the other.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rules</CODE> - the sub rules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="Test(java.lang.Object)"><!-- --></A><H3>
Test</H3>
<PRE>
public org.parboiled.Rule <B>Test</B>(java.lang.Object&nbsp;rule)</PRE>
<DL>
<DD><p>Creates a new rule that acts as a syntactic predicate, i.e. tests the given sub rule against the current
 input position without actually matching any characters. Succeeds if the sub rule succeeds and fails if the
 sub rule rails. Since this rule does not actually consume any input it will never create a parse tree node.</p>
 <p>Also it carries a <A HREF="../../org/parboiled/annotations/SuppressNode.html" title="annotation in org.parboiled.annotations"><CODE>SuppressNode</CODE></A> annotation, which means all sub nodes will also never create a parse
 tree node. This can be important for actions contained in sub rules of this rule that otherwise expect the
 presence of certain parse tree structures in their context.
 Also see <A HREF="../../org/parboiled/annotations/SkipActionsInPredicates.html" title="annotation in org.parboiled.annotations"><CODE>SkipActionsInPredicates</CODE></A></p>
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the subrule
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="Test(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
Test</H3>
<PRE>
public org.parboiled.Rule <B>Test</B>(java.lang.Object&nbsp;rule,
                               java.lang.Object&nbsp;rule2,
                               java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD><p>Creates a new rule that acts as a syntactic predicate, i.e. tests the sequence of the given sub rule against
 the current input position without actually matching any characters. Succeeds if the sub sequence succeeds and
 fails if the sub sequence rails. Since this rule does not actually consume any input it will never create a
 parse tree node.</p>
 <p>Also it carries a <A HREF="../../org/parboiled/annotations/SuppressNode.html" title="annotation in org.parboiled.annotations"><CODE>SuppressNode</CODE></A> annotation, which means all sub nodes will also never create a parse
 tree node. This can be important for actions contained in sub rules of this rule that otherwise expect the
 presence of certain parse tree structures in their context.
 Also see <A HREF="../../org/parboiled/annotations/SkipActionsInPredicates.html" title="annotation in org.parboiled.annotations"><CODE>SkipActionsInPredicates</CODE></A></p>
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="TestNot(java.lang.Object)"><!-- --></A><H3>
TestNot</H3>
<PRE>
public org.parboiled.Rule <B>TestNot</B>(java.lang.Object&nbsp;rule)</PRE>
<DL>
<DD><p>Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given sub rule against the
 current input position without actually matching any characters. Succeeds if the sub rule fails and fails if the
 sub rule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.</p>
 <p>Also it carries a <A HREF="../../org/parboiled/annotations/SuppressNode.html" title="annotation in org.parboiled.annotations"><CODE>SuppressNode</CODE></A> annotation, which means all sub nodes will also never create a parse
 tree node. This can be important for actions contained in sub rules of this rule that otherwise expect the
 presence of certain parse tree structures in their context.
 Also see <A HREF="../../org/parboiled/annotations/SkipActionsInPredicates.html" title="annotation in org.parboiled.annotations"><CODE>SkipActionsInPredicates</CODE></A></p>
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the subrule
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="TestNot(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
TestNot</H3>
<PRE>
public org.parboiled.Rule <B>TestNot</B>(java.lang.Object&nbsp;rule,
                                  java.lang.Object&nbsp;rule2,
                                  java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD><p>Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the sequence of the given sub rules
 against the current input position without actually matching any characters. Succeeds if the sub sequence fails
 and fails if the sub sequence succeeds. Since this rule does not actually consume any input it will never create
 a parse tree node.</p>
 <p>Also it carries a <A HREF="../../org/parboiled/annotations/SuppressNode.html" title="annotation in org.parboiled.annotations"><CODE>SuppressNode</CODE></A> annotation, which means all sub nodes will also never create a parse
 tree node. This can be important for actions contained in sub rules of this rule that otherwise expect the
 presence of certain parse tree structures in their context.
 Also see <A HREF="../../org/parboiled/annotations/SkipActionsInPredicates.html" title="annotation in org.parboiled.annotations"><CODE>SkipActionsInPredicates</CODE></A></p>
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="ZeroOrMore(java.lang.Object)"><!-- --></A><H3>
ZeroOrMore</H3>
<PRE>
public org.parboiled.Rule <B>ZeroOrMore</B>(java.lang.Object&nbsp;rule)</PRE>
<DL>
<DD>Creates a new rule that tries repeated matches of its subrule.
 Succeeds always, even if the subrule doesn't match even once.
 <p>Note: This methods carries a <A HREF="../../org/parboiled/annotations/Cached.html" title="annotation in org.parboiled.annotations"><CODE>Cached</CODE></A> annotation, which means that multiple invocations with the same
 argument will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the subrule
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="ZeroOrMore(java.lang.Object, java.lang.Object, java.lang.Object...)"><!-- --></A><H3>
ZeroOrMore</H3>
<PRE>
public org.parboiled.Rule <B>ZeroOrMore</B>(java.lang.Object&nbsp;rule,
                                     java.lang.Object&nbsp;rule2,
                                     java.lang.Object...&nbsp;moreRules)</PRE>
<DL>
<DD>Creates a new rule that tries repeated matches of the sequence of the given sub rules.
 Succeeds always, even if the sub sequence doesn't match even once.
 <p>Note: This methods provides caching, which means that multiple invocations with the same
 arguments will yield the same rule instance.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rule</CODE> - the first subrule<DD><CODE>rule2</CODE> - the second subrule<DD><CODE>moreRules</CODE> - the other subrules
<DT><B>Returns:</B><DD>a new rule</DL>
</DD>
</DL>
<HR>

<A NAME="ACTION(boolean)"><!-- --></A><H3>
ACTION</H3>
<PRE>
public static org.parboiled.Action <B>ACTION</B>(boolean&nbsp;expression)</PRE>
<DL>
<DD>Explicitly marks the wrapped expression as an action expression.
 parboiled transforms the wrapped expression into an <CODE>Action</CODE> instance during parser construction.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - the expression to turn into an Action
<DT><B>Returns:</B><DD>the Action wrapping the given expression</DL>
</DD>
</DL>
<HR>

<A NAME="fromCharLiteral(char)"><!-- --></A><H3>
fromCharLiteral</H3>
<PRE>
protected org.parboiled.Rule <B>fromCharLiteral</B>(char&nbsp;c)</PRE>
<DL>
<DD>Used internally to convert the given character literal to a parser rule.
 You can override this method, e.g. for specifying a Sequence that automatically matches all trailing
 whitespace after the character.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the character
<DT><B>Returns:</B><DD>the rule</DL>
</DD>
</DL>
<HR>

<A NAME="fromStringLiteral(java.lang.String)"><!-- --></A><H3>
fromStringLiteral</H3>
<PRE>
protected org.parboiled.Rule <B>fromStringLiteral</B>(java.lang.String&nbsp;string)</PRE>
<DL>
<DD>Used internally to convert the given string literal to a parser rule.
 You can override this method, e.g. for specifying a Sequence that automatically matches all trailing
 whitespace after the string.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>string</CODE> - the string
<DT><B>Returns:</B><DD>the rule</DL>
</DD>
</DL>
<HR>

<A NAME="fromCharArray(char[])"><!-- --></A><H3>
fromCharArray</H3>
<PRE>
protected org.parboiled.Rule <B>fromCharArray</B>(char[]&nbsp;array)</PRE>
<DL>
<DD>Used internally to convert the given char array to a parser rule.
 You can override this method, e.g. for specifying a Sequence that automatically matches all trailing
 whitespace after the characters.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the char array
<DT><B>Returns:</B><DD>the rule</DL>
</DD>
</DL>
<HR>

<A NAME="toRules(java.lang.Object...)"><!-- --></A><H3>
toRules</H3>
<PRE>
public org.parboiled.Rule[] <B>toRules</B>(java.lang.Object...&nbsp;objects)</PRE>
<DL>
<DD>Converts the given object array to an array of rules.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objects</CODE> - the objects to convert
<DT><B>Returns:</B><DD>the rules corresponding to the given objects</DL>
</DD>
</DL>
<HR>

<A NAME="toRule(java.lang.Object)"><!-- --></A><H3>
toRule</H3>
<PRE>
public org.parboiled.Rule <B>toRule</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Converts the given object to a rule.
 This method can be overriden to enable the use of custom objects directly in rule specifications.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object to convert
<DT><B>Returns:</B><DD>the rule corresponding to the given object</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/parboiled/BaseActions.html" title="class in org.parboiled"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/parboiled/Parboiled.html" title="class in org.parboiled"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?org/parboiled/BaseParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BaseParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
